package generator

import (
	"bytes"
	"fmt"
	"strings"
	"text/template"

	"github.com/aledsdavies/devcmd/pkg/parser"
)

const defaultTemplate = `#!/bin/sh
# Generated by devcmd - DO NOT EDIT

# === Command Dispatcher Function ===
devcmd() {
  # Store original shell settings to restore them later
  __devcmd_orig_errexit=$(set -o | grep errexit | awk '{print $2}')
  __devcmd_orig_nounset=$(set -o | grep nounset | awk '{print $2}')

  # Capture the exit status for reporting
  __devcmd_status=0

  # Validate arguments
  if [ $# -eq 0 ]; then
    __devcmd_help
  else
    # Process command
    cmd="$1"
    shift

    # Match command
    case "$cmd" in
{{range .Commands}}
      "{{.Name}}")
        { # Use subshell to isolate errors
          (set -e; set -u; # Apply strict mode only inside this subshell
           if [ -n "${BASH_VERSION:-}" ]; then
             set -o pipefail
           fi
           __devcmd_{{.Name}} "$@")
        } || {
          # Capture exit status but don't exit the shell
          __devcmd_status=$?
          echo "Error: Command '{{.Name}}' failed with status $__devcmd_status" >&2
        }
        ;;
{{end}}
      "help"|"--help"|"-h")
        __devcmd_help
        ;;
      *)
        echo "Error: unknown command '$cmd'" >&2
        echo "Run 'devcmd help' to see available commands" >&2
        __devcmd_status=1
        ;;
    esac
  fi

  # Return the status but never exit the shell
  return $__devcmd_status
}

# === Help Command ===
__devcmd_help() {
  echo "Available commands:"
{{range .Commands}}
  echo "  {{.Name}}"
{{end}}
}

# === Command Implementations ===
{{range .Commands}}
__devcmd_{{.Name}}() {
  {{.Command}} "$@"
}
{{end}}

# === Bash Command Completion (Optional) ===
# Only set up completion if running in bash
if [ -n "${BASH_VERSION:-}" ]; then
  __devcmd_completions() {
    # Skip if completion env vars aren't available
    if [ -z "${COMP_WORDS:-}" ] || [ -z "${COMP_CWORD:-}" ]; then
      return 1
    fi

    cur="${COMP_WORDS[COMP_CWORD]}"

    if [ "${COMP_CWORD}" -eq 1 ]; then
      # Complete command name (first argument)
      commands="{{.CommandList}}"
      COMPREPLY=($(compgen -W "$commands" -- "$cur"))
    fi
  }

  # Register completion function
  complete -F __devcmd_completions devcmd
fi
`

// Generate creates a shell script from a CommandFile
func Generate(cf *parser.CommandFile) (string, error) {
	return generateWithCommandList(cf, defaultTemplate)
}

// GenerateWithTemplate creates a shell script with a custom template
func GenerateWithTemplate(cf *parser.CommandFile, templateStr string) (string, error) {
	return generateWithCommandList(cf, templateStr)
}

// TemplateData holds data for the template with pre-built command list
type TemplateData struct {
	Commands    []parser.Command
	CommandList string
}

// generateWithCommandList creates shell script with pre-built command list
func generateWithCommandList(cf *parser.CommandFile, templateStr string) (string, error) {
	// Validate inputs
	if cf == nil {
		return "", fmt.Errorf("command file cannot be nil")
	}
	if len(templateStr) == 0 {
		return "", fmt.Errorf("template string cannot be empty")
	}

	// Build command list for completion
	var cmdNames []string
	for _, cmd := range cf.Commands {
		cmdNames = append(cmdNames, cmd.Name)
	}
	cmdNames = append(cmdNames, "help")

	// Create template data with command list
	data := TemplateData{
		Commands:    cf.Commands,
		CommandList: strings.Join(cmdNames, " "),
	}

	// Parse template
	tmpl, err := template.New("shell").Parse(templateStr)
	if err != nil {
		return "", fmt.Errorf("failed to parse template: %w", err)
	}

	// Execute template
	var buf bytes.Buffer
	err = tmpl.Execute(&buf, data)
	if err != nil {
		return "", fmt.Errorf("failed to execute template: %w", err)
	}

	// Verify output
	result := buf.String()
	if len(result) == 0 {
		return "", fmt.Errorf("generated empty shell script")
	}

	return result, nil
}
