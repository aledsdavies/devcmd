package generator

import (
	"bytes"
	"fmt"
	"strings"
	"text/template"

	"github.com/aledsdavies/devcmd/pkgs/parser"
)

const defaultTemplate = `#!/bin/sh
# Generated by devcmd - DO NOT EDIT

# === Variables ===
DEVCMD_DIR=".devcmd"

# === Command Dispatcher Function ===
devcmd() {
  # Create devcmd directory if it doesn't exist
  mkdir -p "$DEVCMD_DIR"

  # Store original shell settings to restore them later
  __devcmd_orig_errexit=$(set -o | grep errexit | awk '{print $2}')
  __devcmd_orig_nounset=$(set -o | grep nounset | awk '{print $2}')

  # Capture the exit status for reporting
  __devcmd_status=0

  # Validate arguments
  if [ $# -eq 0 ]; then
    __devcmd_help
  else
    # Process command
    cmd="$1"
    shift

    # Match command
    case "$cmd" in
{{range .Commands}}
      "{{.Name}}")
        { # Use subshell to isolate errors
          (set -e; set -u; # Apply strict mode only inside this subshell
           if [ -n "${BASH_VERSION:-}" ]; then
             set -o pipefail
           fi
{{if .IsWatch}}
           # Watch command - launch in background
           __devcmd_watch_{{.Name}} "$@"
           trap '__devcmd_stop_{{.Name}}' INT TERM EXIT
           wait # Wait for children processes
{{else if .IsStop}}
           # Stop command - terminate associated processes
           __devcmd_stop_{{.Name}} "$@"
{{else}}
           # Regular command
           __devcmd_{{.Name}} "$@"
{{end}}
          )
        } || {
          # Capture exit status but don't exit the shell
          __devcmd_status=$?
          echo "Error: Command '{{.Name}}' failed with status $__devcmd_status" >&2
        }
        ;;
{{end}}
      "help"|"--help"|"-h")
        __devcmd_help
        ;;
      *)
        echo "Error: unknown command '$cmd'" >&2
        echo "Run 'devcmd help' to see available commands" >&2
        __devcmd_status=1
        ;;
    esac
  fi

  # Return the status but never exit the shell
  return $__devcmd_status
}

# === Help Command ===
__devcmd_help() {
  echo "Available commands:"
{{range .Commands}}
  echo "  {{.Name}}{{if .IsWatch}} (watch){{else if .IsStop}} (stop){{end}}"
{{end}}
}

# === Command Implementations ===
{{range .Commands}}
{{if .IsWatch}}
# Watch function for {{.Name}}
__devcmd_watch_{{.Name}}() {
  echo "Starting watch command: {{.Name}}"

  # Launch watch processes in a new process group
  setsid sh -c '
{{if .IsBlock}}
    # Block command with statements
{{range .Block}}
    {{.Command}}{{if .Background}} &{{end}}
{{end}}
{{else}}
    # Simple command
    {{.Command}}
{{end}}
    wait  # Wait for background processes in this subshell
  ' &

  # Store process group ID for later termination
  echo $! > "$DEVCMD_DIR/{{.Name}}.pgid"
  echo "Started {{.Name}} (PGID: $(cat $DEVCMD_DIR/{{.Name}}.pgid))"
}

{{else if .IsStop}}
# Stop function for {{.Name}}
__devcmd_stop_{{.Name}}() {
  echo "Stopping processes for {{.Name}}"

  # Run user-defined stop commands first
{{if .IsBlock}}
  # Block command with statements
{{range .Block}}
  {{.Command}}{{if .Background}} &{{end}}
{{end}}
{{else}}
  # Simple command
  {{.Command}}
{{end}}

  # Terminate the process group if PGID file exists
  pgid_file="$DEVCMD_DIR/{{.BaseName}}.pgid"
  if [ -f "$pgid_file" ]; then
    pgid=$(cat "$pgid_file")
    echo "Terminating process group: $pgid"

    # Send TERM signal first
    kill -TERM -"$pgid" 2>/dev/null || true

    # Give processes time to exit gracefully
    sleep 2

    # Force kill if still running
    kill -KILL -"$pgid" 2>/dev/null || true

    # Remove PGID file
    rm -f "$pgid_file"
  else
    echo "No running process group found for {{.BaseName}}"
  fi
}

{{else}}
# Regular command function
__devcmd_{{.Name}}() {
{{if .IsBlock}}
  # Block command with statements
{{range .Block}}
  {{.Command}}{{if .Background}} &{{end}}
{{end}}
{{if .HasBackground}}
  # Wait for background processes to complete
  wait
{{end}}
{{else}}
  # Simple command
  {{.Command}} "$@"
{{end}}
}
{{end}}
{{end}}

# === Bash Command Completion (Optional) ===
# Only set up completion if running in bash
if [ -n "${BASH_VERSION:-}" ]; then
  __devcmd_completions() {
    # Skip if completion env vars aren't available
    if [ -z "${COMP_WORDS:-}" ] || [ -z "${COMP_CWORD:-}" ]; then
      return 1
    fi
    cur="${COMP_WORDS[COMP_CWORD]}"
    if [ "${COMP_CWORD}" -eq 1 ]; then
      # Complete command name (first argument)
      commands="{{.CommandList}}"
      COMPREPLY=($(compgen -W "$commands" -- "$cur"))
    fi
  }
  # Register completion function
  complete -F __devcmd_completions devcmd
fi
`

// EnhancedCommand adds additional properties needed for the template
type EnhancedCommand struct {
	parser.Command
	BaseName      string // For stop commands, the base name without 'stop'
	HasBackground bool   // Whether any block statements have Background=true
}

// TemplateData holds data for the template with pre-built command list
type TemplateData struct {
	Commands    []EnhancedCommand
	CommandList string
}

// Generate creates a shell script from a CommandFile
func Generate(cf *parser.CommandFile) (string, error) {
	return generateWithCommandList(cf, defaultTemplate)
}

// GenerateWithTemplate creates a shell script with a custom template
func GenerateWithTemplate(cf *parser.CommandFile, templateStr string) (string, error) {
	return generateWithCommandList(cf, templateStr)
}

// generateWithCommandList creates shell script with pre-built command list
func generateWithCommandList(cf *parser.CommandFile, templateStr string) (string, error) {
	// Validate inputs
	if cf == nil {
		return "", fmt.Errorf("command file cannot be nil")
	}
	if len(templateStr) == 0 {
		return "", fmt.Errorf("template string cannot be empty")
	}

	// Expand command list with additional properties
	enhancedCommands := enhanceCommands(cf.Commands)

	// Build command list for completion
	var cmdNames []string
	for _, cmd := range enhancedCommands {
		cmdNames = append(cmdNames, cmd.Name)
	}
	cmdNames = append(cmdNames, "help")

	// Create template data with command list
	data := TemplateData{
		Commands:    enhancedCommands,
		CommandList: strings.Join(cmdNames, " "),
	}

	// Parse template
	tmpl, err := template.New("shell").Parse(templateStr)
	if err != nil {
		return "", fmt.Errorf("failed to parse template: %w", err)
	}

	// Execute template
	var buf bytes.Buffer
	err = tmpl.Execute(&buf, data)
	if err != nil {
		return "", fmt.Errorf("failed to execute template: %w", err)
	}

	// Verify output
	result := buf.String()
	if len(result) == 0 {
		return "", fmt.Errorf("generated empty shell script")
	}

	return result, nil
}

// enhanceCommands adds additional properties needed for the template
func enhanceCommands(commands []parser.Command) []EnhancedCommand {
	var enhanced []EnhancedCommand

	for _, cmd := range commands {
		enh := EnhancedCommand{
			Command: cmd,
		}

		// For stop commands, set BaseName (remove 'stop' prefix)
		if cmd.IsStop {
			enh.BaseName = strings.TrimPrefix(cmd.Name, "stop")
			// If name begins with "-", remove it
			if strings.HasPrefix(enh.BaseName, "-") {
				enh.BaseName = enh.BaseName[1:]
			}
		}

		// For block commands, check if any statements have background=true
		if cmd.IsBlock {
			for _, stmt := range cmd.Block {
				if stmt.Background {
					enh.HasBackground = true
					break
				}
			}
		}

		enhanced = append(enhanced, enh)
	}

	return enhanced
}
